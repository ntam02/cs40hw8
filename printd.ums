## printd.ums
# r6 and r7 are temp registers, clobbered by this function
# r5 is volatile register, holds return address temporarily
# r2 always holds stack pointer
#
# when function is called, r1 holds return address,
# r1 will hold return value when program ends
        .temps r6, r7
        .section text
printd:
        push r1 on stack r2     # save return address
        push r4 on stack r2
        push sentinel on stack r3
        r4 := m[r0][r2 + 2]     # assume parameter is pushed to stack by caller
        output ">>> "
        if (r4 <s 0) goto handle_sign using r1   # check negetivity first
        goto destruct_loop

finish:
        output '\n'
        # sentinel is popped already, no worry about this
        pop r4 off stack r2
        pop r5 off stack r2           # get r1 return address back then exit
        goto r5

handle_sign:
        r4 := - r4
        if (r4 <s 0) goto print_min using r1
        output '-'
        goto destruct_loop


print_loop:
        pop r5 off stack r3
        if (r5 == sentinel) goto finish using r1
        r5 := r5 + '0'
        output r5
        goto print_loop


# push all digits from least to most to vstack
destruct_loop:
        r1 := r4 mod 10
        push r1 on stack r3
        r4 := r4 / 10
        if (r4 == 0) goto print_loop
        goto destruct_loop


print_min:
        output "-2147483648"
        pop stack r3    # pop sentinel
        goto finish

sentinel: