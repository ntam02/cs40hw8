## printd.ums
# r6 and r7 are temp registers, clobbered by this function
# r5 is volatile register, holds return address temporarily
# r2 always holds stack pointer
#
# when function is called, r1 holds return address,
# r1 will hold return value when program ends
        .temps r6, r7
        .section text
printd:
        push r1 on stack r2     # save return address
        push r3 on stack r2
        push r4 on stack r2
        r3 := m[r0][r2 + 3]     # assume parameter is pushed to stack by caller
        output ">>> "
        if (r3 <s 0) goto handle_sign using r1   # check negetivity first
        goto find_div_one

finish:
        output '\n'
        pop r4 off stack r2
        pop r3 off stack r2
        pop r5 off stack r2           # get r1 return address back then exit
        goto r5

handle_sign:
        r3 := - r3
        if (r3 <s 0) goto print_min using r1
        output '-'
        goto find_div_one


print_loop:
        r4 := r4 / 10
        if (r4 == 0) goto finish
        r1 := r3 / r4
        output r1 + '0'
        r3 := r3 mod r4 using r1, r5
        goto print_loop



find_div_one:
        r4 := 10
find_loop:
        r1 := r3 / r4
        if (r1 == 0) goto print_loop
        r4 := r4 * 10
        goto find_loop


print_min:
        output "-2147483648"
        goto finish